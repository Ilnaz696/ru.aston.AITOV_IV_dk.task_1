
Ответы на вопросы по Java:

1. Основные принципы ООП:

   Объектно-ориентированное программирование строится на нескольких фундаментальных идеях:
   Инкапсуляция: Это как капсула с лекарством. Мы прячем “внутренности” объекта (данные и методы) от внешнего мира и предоставляем только контролируемый доступ через “оболочку” (публичные методы). Это защищает данные от случайного изменения и упрощает изменение внутренней реализации класса, не затрагивая остальную часть программы.
   Наследование: Это как генетика. Класс-потомок получает “гены” (поля и методы) от класса-родителя. Он может добавлять свои “гены” или изменять существующие. Наследование позволяет избежать дублирования кода и создавать иерархии классов, отражающие отношения “is-a” (например, “Собака - это животное”).
   Полиморфизм: Это как умение перевоплощаться. Один и тот же метод может вести себя по-разному в разных классах. Например, метод “издатьЗвук” у “Кошки” будет “Мяу”, а у “Собаки” - “Гав”. Полиморфизм позволяет писать более гибкий и обобщенный код, который может работать с разными типами объектов единообразно.
   Абстракция: Это как упрощенная карта местности. Мы убираем ненужные детали и сосредотачиваемся на главном. Абстрактные классы и интерфейсы позволяют определять общие свойства и поведение для группы классов, не указывая конкретную реализацию.
2. Иерархия наследования и методы класса Object:
   В Java все классы (явно или неявно) наследуются от класса Object. Это вершина иерархии наследования. Класс Object предоставляет набор базовых методов, которые доступны каждому объекту в Java:
   equals(Object obj): Проверяет, равны ли два объекта. По умолчанию сравнивает ссылки на объекты. Важно переопределить, если нужно сравнивать содержимое объектов.
   hashCode(): Возвращает хеш-код объекта. Используется для быстрого поиска объектов в коллекциях (например, в HashMap). Важно переопределить, если переопределен equals().
   toString(): Возвращает строковое представление объекта. По умолчанию возвращает имя класса и хеш-код. Полезно переопределить, чтобы получить более информативное описание объекта.
   getClass(): Возвращает объект класса Class, представляющий класс данного объекта.
   notify(), notifyAll(), wait(): Методы для работы с многопоточностью. Используются для синхронизации потоков.
   finalize(): Метод, который вызывается сборщиком мусора перед удалением объекта. Не рекомендуется использовать, так как его поведение непредсказуемо.
3. Интерфейс и абстрактный класс:
   Интерфейс: Это чистый контракт. Он определяет что класс должен делать, но не говорит как. Интерфейс содержит только абстрактные методы (и константы). Класс может реализовать несколько интерфейсов. Это как список требований к кандидату на работу.
   Абстрактный класс: Это как незаконченное здание. Он может содержать как абстрактные методы (которые должны быть реализованы в подклассах), так и конкретные методы (с реализацией). Класс может наследоваться только от одного абстрактного класса.
4. Конструкторы, поля, статические/дефолтные методы в интерфейсах и абстрактных классах:
   Интерфейс:
   Конструкторы: Нет (нельзя создать экземпляр интерфейса).
   Поля: Только константы (public static final).
   Статические методы: Да (начиная с Java 8).
   Дефолтные методы: Да (начиная с Java 8). Позволяют добавлять новую функциональность в интерфейсы, не ломая существующие реализации.
   Абстрактный класс:
   Конструкторы: Да. Используются для инициализации полей в подклассах. Нельзя создать экземпляр абстрактного класса напрямую, но конструктор вызывается при создании экземпляра подкласса.
   Поля: Да, любые.
   Статические методы: Да.
   Дефолтные методы: Нет (это концепция интерфейсов).
5. Enum:
   Enum (перечисление) – это специальный тип класса, который представляет собой набор именованных констант.
   Отличия от класса:
   Enum представляет фиксированный набор значений.
   Экземпляры Enum создаются автоматически при объявлении перечисления.
   Enum не может наследоваться от других классов (но может реализовывать интерфейсы).
   Возможности:
   Методы: Да, Enum может содержать методы.
   Конструкторы: Да, Enum может иметь конструкторы (private).
   Наследование: Нет, Enum не может наследоваться от классов.
   Реализация интерфейсов: Да, Enum может реализовывать интерфейсы.
6. Модификаторы доступа:
   Модификаторы доступа контролируют видимость и доступность членов класса (полей, методов, конструкторов) из других частей программы.
   public: Доступно отовсюду.
   protected: Доступно внутри класса, в подклассах (даже в других пакетах) и в классах в том же пакете.
   package-private (без модификатора): Доступно только внутри пакета.
   private: Доступно только внутри класса.
   Модификаторы доступа применяются к классам, полям, методам и конструкторам.
7. Конструкторы и модификаторы доступа:
   Конструкторы могут иметь любые модификаторы доступа: public, protected, package-private, private.
   public: Позволяет создавать экземпляры класса из любого места.
   protected: Позволяет создавать экземпляры класса только внутри пакета и в подклассах.
   package-private: Позволяет создавать экземпляры класса только внутри пакета.
   private: Запрещает создание экземпляров класса извне (используется в Singleton и для утилитных классов).
   Конструкторы не наследуются и не переопределяются. Подклассы могут вызывать конструкторы суперкласса с помощью super().
8. Реализация нескольких интерфейсов с одинаковым методом:
   Да, класс может реализовать два интерфейса с одинаковым методом doSmth. Реализация будет общей для обоих интерфейсов. Класс реализует метод doSmth один раз, и эта реализация удовлетворяет контрактам обоих интерфейсов.
9. Статический и динамический полиморфизм:
   Статический полиморфизм (Compile-time polymorphism): Реализуется с помощью перегрузки методов. Компилятор выбирает, какой метод вызвать, на основе типов аргументов во время компиляции.
   Динамический полиморфизм (Runtime polymorphism): Реализуется с помощью переопределения методов и наследования. JVM выбирает, какой метод вызвать, во время выполнения, на основе фактического типа объекта.
10. Члены класса:
    Членами класса являются:
    Поля (переменные экземпляра и статические переменные)
    Методы (экземпляра и статические методы)
    Конструкторы
    Вложенные классы и интерфейсы
    Статические блоки инициализации
    Нестатические блоки инициализации
11. Переопределение и перегрузка методов:
    Переопределение (Overriding): Создание метода в подклассе с той же сигнатурой (имя и параметры), что и метод в суперклассе. Используется для изменения поведения унаследованного метода.
    Модификатор доступа не может быть более строгим, чем в суперклассе.
    Тип возвращаемого значения должен быть таким же, как в суперклассе, или ковариантным (подтипом).
    Метод не может быть private или final.
    Перегрузка (Overloading): Создание нескольких методов с одним и тем же именем в одном классе, но с разными сигнатурами (разное количество, типы или порядок параметров).
12. JVM, JRE, JDK:
    (Ответы даны в предыдущих пунктах. См. пункт 2)
13. Classpath и соглашения об именовании пакетов:
    Classpath: Это список каталогов и JAR-файлов, которые JVM использует для поиска классов во время выполнения. Он указывает JVM, где искать скомпилированные .class файлы. Classpath может быть указан с помощью переменной среды CLASSPATH или с помощью опции -classpath (или -cp) при запуске JVM.
    Соглашения об именовании пакетов:
    Имена пакетов должны быть в нижнем регистре.
    Имена пакетов должны начинаться с обратного доменного имени вашей организации (например, com.example).
    Далее следуют имена подпакетов, отражающие структуру проекта (например, com.example.myapp.model).
14. Comparator и Comparable:
    Comparable: Интерфейс, который класс реализует, чтобы объекты этого класса можно было сравнивать между собой. Определяет естественный порядок сравнения. Содержит метод compareTo(T o).
    Comparator: Интерфейс, который определяет стратегию сравнения для объектов другого класса. Позволяет определить несколько разных способов сравнения. Содержит метод compare(T o1, T o2).
15. Класс String и пул строк:
    String – это неизменяемый (immutable) класс, представляющий последовательность символов.
    Пул строк (String Pool): Это область памяти в куче, где хранятся литеральные строки (например, "hello"). Когда создается строковый литерал, JVM проверяет, есть ли уже такая строка в пуле. Если есть, возвращается ссылка на существующую строку. Если нет, создается новая строка в пуле. Это позволяет экономить память и улучшать производительность. Строки, созданные с помощью new String(), не помещаются в пул автоматически (но их можно поместить туда с помощью метода intern()).
16. super, this, class, instanceof:
    super: Ссылка на суперкласс. Используется для вызова конструктора суперкласса (super()) и для доступа к полям и методам суперкласса (super.method()).
    this: Ссылка на текущий объект. Используется для доступа к полям и методам текущего объекта и для вызова одного конструктора из другого в том же классе (this()).
    class: Ключевое слово для объявления класса. Также используется для получения объекта Class (например, MyClass.class).
    instanceof: Оператор для проверки, является ли объект экземпляром определенного класса или реализует ли он определенный интерфейс (например, object instanceof MyClass).
17. Массивы в Java:
    Массивы в Java - это объекты.
    Они хранят элементы одного и того же типа.
    Размер массива фиксируется при создании и не может быть изменен.
    Можно создать массив нулевой длины (например, int[] arr = new int[0];).
    Массивы относятся к типу ссылочных типов (reference types).
18. Этапы создания и запуска блоков/конструкторов класса при наследовании:
    При создании объекта подкласса выполняются следующие шаги:
    Статические блоки инициализации суперкласса: Выполняются только один раз, при загрузке суперкласса в память.
    Статические блоки инициализации подкласса: Выполняются только один раз, при загрузке подкласса в память.
    Нестатические блоки инициализации суперкласса: Выполняются для каждого создаваемого объекта.
    Конструктор суперкласса: Вызывается конструктор суперкласса (явно или неявно).
    Нестатические блоки инициализации подкласса: Выполняются для каждого создаваемого объекта.
    Конструктор подкласса: Выполняется конструктор подкласса.
19. break и continue в циклах:
    break: Прерывает выполнение цикла и передает управление на строку кода, следующую после цикла.
    continue: Прерывает текущую итерацию цикла и переходит к следующей итерации.
20. Generics:
    Generics (обобщения) – это механизм, позволяющий создавать классы, интерфейсы и методы, которые работают с разными типами данных без необходимости указывать конкретный тип во время компиляции. Они обеспечивают типобезопасность и позволяют избежать приведения типов (casting).
21. Ключевое слово final:
    final может применяться к:
    Классам: Запрещает наследование класса.
    Методам: Запрещает переопределение метода в подклассах.
    Переменным: Делает переменную константой. Значение final переменной не может быть изменено после инициализации.
22. Optional:
    Optional – это класс-контейнер, который может содержать или не содержать значение. Он предназначен для обработки случаев, когда значение может отсутствовать (null). Использование Optional помогает избежать NullPointerException и делает код более читаемым и безопасным.
23. Big O нотация:
    Big O нотация - это способ описания асимптотической сложности алгоритма. Она показывает, как время выполнения или потребление памяти алгоритма растет в зависимости от размера входных данных (обозначается как “n”). Фактически, Big O измеряет скорость роста ресурсоемкости алгоритма.
    Что описывает: Верхнюю границу роста ресурсов (обычно времени выполнения). Она показывает, как долго будет работать алгоритм в худшем случае или в среднем.
    Как высчитывается: Обычно анализируется код алгоритма и подсчитывается количество операций, выполняемых в зависимости от размера входных данных. Опускаются константы и низкопорядковые члены.
    Что фактически измеряется: Не конкретное время выполнения в секундах, а характер роста времени (или памяти).
    Примеры:
    O(1) - константное время: Время выполнения не зависит от размера входных данных (например, доступ к элементу массива по индексу).
    O(log n) - логарифмическое время: Время выполнения растет очень медленно (например, бинарный поиск).
    O(n) - линейное время: Время выполнения растет линейно с размером входных данных (например, поиск элемента в списке).
    O(n log n) - квазилинейное время: Часто встречается в алгоритмах сортировки (например, сортировка слиянием, быстрая сортировка).
    O(n^2) - квадратичное время: Время выполнения растет пропорционально квадрату размера входных данных (например, пузырьковая сортировка, сортировка выбором).
    O(2^n) - экспоненциальное время: Время выполнения быстро растет (например, алгоритмы, перебирающие все подмножества множества).
    Пример: Если у вас есть цикл, который выполняется n раз, а внутри цикла есть операция, выполняющаяся за константное время, то сложность этого фрагмента кода - O(n).
24. Основные алгоритмы сортировки (принцип работы):
    Алгоритмы сортировки упорядочивают элементы в списке (массиве) в определенном порядке (обычно возрастающем или убывающем).
    Сортировка пузырьком: Сравниваются соседние элементы и, при необходимости, меняются местами. Большие элементы “всплывают” в конец списка.
    Сортировка выбором: На каждой итерации ищется минимальный (или максимальный) элемент в несортированной части списка и меняется местами с первым элементом этой части.
    Сортировка вставками: Список условно делится на отсортированную и несортированную части. Элементы из несортированной части по очереди вставляются в правильное положение в отсортированной части.
    Быстрая сортировка: Алгоритм “разделяй и властвуй”. Выбирается “опорный” элемент (pivot). Список разбивается на две части: элементы меньше опорного и элементы больше опорного. Рекурсивно сортируются эти две части.
    Сортировка слиянием: Алгоритм “разделяй и властвуй”. Список разбивается на две половины, которые рекурсивно сортируются. Затем отсортированные половины сливаются в один отсортированный список.
25. Пузырьковая сортировка:
    Принцип работы: Проходим по списку несколько раз. На каждом проходе сравниваем соседние элементы и меняем их местами, если они находятся в неправильном порядке. Большие элементы “всплывают” в конец.
    Сложность:
    Худший случай: O(n^2)
    Лучший случай: O(n) (если список уже отсортирован)
    Средний случай: O(n^2)
    Память: O(1) (in-place, сортировка “на месте” - не требует дополнительной памяти, кроме нескольких переменных для обмена элементами).
26. Сортировка выбором:
    Принцип работы: На каждой итерации ищем минимальный (или максимальный) элемент в несортированной части списка и меняем его местами с первым элементом этой части.
    Сложность:
    Худший случай: O(n^2)
    Лучший случай: O(n^2)
    Средний случай: O(n^2)
    Память: O(1) (in-place).
27. Сортировка вставками:
    Принцип работы: Список делится на отсортированную и несортированную части. Элементы из несортированной части по очереди вставляются в правильное положение в отсортированной части.
    Сложность:
    Худший случай: O(n^2)
    Лучший случай: O(n) (если список уже отсортирован)
    Средний случай: O(n^2)
    Память: O(1) (in-place).
28. Быстрая сортировка:
    Принцип работы: “Разделяй и властвуй”. Выбирается “опорный” элемент (pivot). Список разбивается на две части: элементы меньше опорного и элементы больше опорного. Рекурсивно сортируются эти две части.
    Сложность:
    Худший случай: O(n^2) (редко, если опорный элемент выбирается неудачно)
    Лучший случай: O(n log n)
    Средний случай: O(n log n)
    Память: O(log n) (в среднем, из-за рекурсии). В худшем случае может быть O(n).
29. Сортировка слиянием:
    Принцип работы: “Разделяй и властвуй”. Список разбивается на две половины, которые рекурсивно сортируются. Затем отсортированные половины сливаются в один отсортированный список.
    Сложность:
    Худший случай: O(n log n)
    Лучший случай: O(n log n)
    Средний случай: O(n log n)
    Память: O(n) (требуется дополнительная память для слияния).
30. Жадный алгоритм:
    Жадный алгоритм – это алгоритм, который на каждом шаге делает локально оптимальный выбор, в надежде, что это приведет к глобально оптимальному решению. Он не всегда находит оптимальное решение для всех задач, но часто дает хорошие результаты.
31. Бинарный поиск:
    Бинарный поиск – это алгоритм поиска элемента в отсортированном списке. На каждом шаге алгоритм сравнивает искомый элемент со средним элементом списка. Если они равны, поиск завершен. Если искомый элемент меньше среднего, поиск продолжается в левой половине списка. Если искомый элемент больше среднего, поиск продолжается в правой половине списка.
    Сложность: O(log n).
32. Алгоритмы поиска пути (обход графов): обход в глубину, обход в ширину:
    Эти алгоритмы используются для обхода графов (структур данных, представляющих собой набор узлов и ребер между ними).
    Обход в глубину (Depth-First Search - DFS):
    Начинаем с выбранного узла.
    Идем в “глубину”, то есть переходим в первый доступный соседний узел.
    Повторяем, пока не дойдем до узла, из которого нет непройденных соседей.
    Возвращаемся назад (backtrack) и пробуем другие варианты.
    Используется стек для хранения узлов для возврата.
    Обход в ширину (Breadth-First Search - BFS):
    Начинаем с выбранного узла.
    Посещаем все соседние узлы этого узла.
    Затем посещаем все соседние узлы каждого из посещенных узлов, и так далее.
    Используется очередь для хранения узлов для посещения.
33. Структуры данных, которые вы знаете:
    Массивы: Упорядоченный набор элементов одного типа.
    Связанные списки: Набор элементов, где каждый элемент содержит ссылку на следующий элемент.
    Стеки: Структура данных LIFO (Last-In, First-Out).
    Очереди: Структура данных FIFO (First-In, First-Out).
    Деревья: Иерархическая структура данных, состоящая из узлов и ребер (например, бинарные деревья, деревья поиска).
    Хеш-таблицы (HashMap, HashTable): Структура данных, использующая хеш-функцию для быстрого поиска элементов по ключу.
    Графы: Структура данных, представляющая собой набор узлов и ребер между ними.
    Кучи (Heaps): Древовидная структура данных, удовлетворяющая свойству кучи (например, бинарная куча).
34. Массивы: достоинства и недостатки:
    Достоинства:
    Быстрый доступ к элементам по индексу (O(1)).
    Простота использования.
    Эффективное использование памяти (если размер известен заранее).
    Недостатки:
    Фиксированный размер (в большинстве языков, включая Java).
    Вставка и удаление элементов в середине массива требуют сдвига элементов (O(n)).
35. Связанные списки: достоинства, недостатки, временная сложность (добавление/поиск/удаление):
    Достоинства:
    Динамический размер (легко добавлять и удалять элементы).
    Эффективная вставка и удаление в любом месте списка (O(1) при наличии ссылки на предыдущий элемент).
    Недостатки:
    Медленный доступ к элементам по индексу (O(n)).
    Требуется дополнительная память для хранения ссылок на следующие элементы.
    Временная сложность:
    Добавление в начало/конец: O(1)
    Добавление в середину (после известного элемента): O(1)
    Поиск: O(n)
    Удаление (при наличии ссылки на предыдущий элемент): O(1)
    Удаление (по значению): O(n)
36. Стек: достоинства, недостатки, временная сложность (добавление/поиск/удаление):
    Достоинства:
    Простая структура данных.
    Эффективная реализация (добавление и удаление в конец).
    Недостатки:
    Доступ к элементам только в порядке LIFO.
    Временная сложность:
    Добавление (push): O(1)
    Удаление (pop): O(1)
    Поиск: O(n) (если нужно найти элемент в стеке, придется “вытаскивать” элементы)
37. Очередь: достоинства, недостатки, временная сложность (добавление/поиск/удаление):
    Достоинства:
    Простая структура данных.
    Используется для обработки элементов в порядке FIFO.
    Недостатки:
    Доступ к элементам только в порядке FIFO.
    Временная сложность:
    Добавление (enqueue): O(1)
    Удаление (dequeue): O(1)
    Поиск: O(n) (если нужно найти элемент в очереди, придется “вытаскивать” элементы)
38. Деревья: достоинства, недостатки, временная сложность (добавление/поиск/удаление):
    Достоинства:
    Иерархическая структура данных, представляющая отношения между элементами.
    Эффективный поиск (например, в бинарных деревьях поиска).
    Недостатки:
    Сложность реализации (по сравнению с линейными структурами данных).
    Балансировка деревьев может быть сложной задачей.
    Временная сложность (для сбалансированных деревьев, например, AVL или Red-Black Tree):
    Добавление: O(log n)
    Поиск: O(log n)
    Удаление: O(log n)
39. Основные группы типов данных:
    Примитивные типы данных (primitive data types): Хранят непосредственно значения (числа, символы, логические значения).
    Ссылочные типы данных (reference data types): Хранят ссылки на объекты (экземпляры классов).
40. Примитивные типы данных (Java):
    byte: Целое число (8 бит).
    short: Целое число (16 бит).
    int: Целое число (32 бита).
    long: Целое число (64 бита).
    float: Число с плавающей точкой (32 бита).
    double: Число с плавающей точкой (64 бита).
    boolean: Логическое значение (true или false).
    char: Символ (16 бит, Unicode).
41. Преобразование примитивных типов данных:
    Преобразование типов (Type Casting):
    Неявное (Implicit): Преобразование выполняется автоматически, когда данные одного типа преобразуются в более “широкий” тип (например, int в long). Потери данных нет.
    Явное (Explicit): Преобразование, которое необходимо выполнить вручную (например, приведение double к int). Может привести к потере данных (отсечение дробной части).
    Преобразование логического типа: Нельзя напрямую преобразовать boolean в числовой тип или наоборот. Для этого нужно использовать условные операторы (if-else) или тернарный оператор.
    Пример (Явное преобразование):
    int i = 10;
    double d = (double) i; // Явное преобразование int в double (не потеря данных)
    double pi = 3.14159;
    int intPi = (int) pi; // Явное преобразование double в int (потеря дробной части, intPi будет 3)

42. Значения по умолчанию для переменных:
    Если переменная примитивного типа объявлена, но не инициализирована, ей присваивается значение по умолчанию:
    byte, short, int, long: 0
    float: 0.0f
    double: 0.0d
    boolean: false
    char: \u0000 (нулевой символ)
    Ссылочные типы (объекты): null
43. Передача значения переменной (по ссылке/значению):
    Примитивные типы: Передаются по значению. При изменении значения параметра внутри метода, исходная переменная остается неизменной.
    Ссылочные типы: Передаются по ссылке (фактически, по значению ссылки). В метод передается копия ссылки на объект. Если метод изменяет состояние объекта через эту ссылку, изменения будут видны за пределами метода.
44. Классы-обертки:
    Классы-обертки (Wrapper classes) - это классы, которые обертывают примитивные типы данных в объекты.
    Назначение:
    Позволяют работать с примитивными типами как с объектами (например, использовать их в коллекциях, которые принимают только объекты).
    Предоставляют полезные методы для работы с примитивными типами (например, преобразование в строку, получение максимального/минимального значения).
    Примеры:
    Integer (для int)
    Double (для double)
    Boolean (для boolean)
    Character (для char)
    Byte (для byte)
    Short (для short)
    Long (для long)
    Float (для float)
45. Определение коллекции:
    Коллекция (Collection) в Java – это фреймворк, предоставляющий структуру данных для хранения и управления наборами объектов. Он обеспечивает различные способы организации и доступа к данным.
46. Преимущества использования коллекций:
    Динамическое изменение размера: Размер коллекций может изменяться во время выполнения.
    Унифицированный API: Предоставляет стандартный набор методов для работы с данными (добавление, удаление, поиск, перебор и т.д.).
    Типобезопасность: Использование Generics позволяет обеспечить типобезопасность (коллекции могут хранить только объекты определенного типа).
    Готовые реализации: Предоставляет готовые реализации различных структур данных (например, ArrayList, HashSet, HashMap).
47. Объекты, которые можно хранить в коллекциях:
    В коллекциях можно хранить объекты (экземпляры классов). Примитивные типы можно хранить только через классы-обертки.
48. Иерархия коллекций:
    Фреймворк коллекций Java организован в иерархию интерфейсов:
    Collection (базовый интерфейс): определяет общие методы для работы с коллекциями.
    List: Упорядоченная коллекция, допускающая дубликаты.
    ArrayList
    LinkedList
    Vector
    Stack
    Set: Коллекция, не допускающая дубликаты.
    HashSet
    TreeSet
    LinkedHashSet
    Queue: Коллекция, предназначенная для обработки элементов в определенном порядке (например, FIFO).
    LinkedList (реализует Queue)
    PriorityQueue
    Map: Коллекция, хранящая пары ключ-значение. Ключи должны быть уникальными.
    HashMap
    TreeMap
    LinkedHashMap
    Hashtable (устаревший)
49. Отличия Vector от ArrayList:
    Vector - устаревший класс.
    ArrayList - более современный.
    Vector является потокобезопасным (synchronized), в то время как ArrayList – нет. Это означает, что при работе с Vector из нескольких потоков доступ к нему синхронизируется, что может снижать производительность. ArrayList обеспечивает более высокую производительность в однопоточных приложениях.
    Vector увеличивает свой размер на удвоенный размер при необходимости (по умолчанию), а ArrayList увеличивает свой размер примерно на 50%.
50. Коллекции типа List (добавление элемента, расширение):
    List – упорядоченная коллекция, допускающая дубликаты.
    Добавление элемента:
    add(E element): Добавляет элемент в конец списка.
    add(int index, E element): Добавляет элемент по указанному индексу.
    Расширение: List автоматически расширяется по мере добавления новых элементов. Реализация (например, ArrayList) выделяет новый массив большей емкости, когда текущий массив заполнен. Элементы копируются в новый массив.
51. Коллекции типа Set:
    Set – коллекция, не допускающая дубликаты. Элементы хранятся в уникальном порядке.
    Основные реализации:
    HashSet: Неупорядоченная коллекция, использует хеш-функцию для хранения элементов. Быстрый поиск, добавление и удаление.
    TreeSet: Упорядоченная коллекция, хранит элементы в отсортированном порядке (по умолчанию - в возрастающем). Использует дерево для хранения элементов. Более медленный поиск, добавление и удаление, чем у HashSet.
    LinkedHashSet: Сохраняет порядок добавления элементов. Сочетает в себе характеристики HashSet и LinkedList.
52. Коллекции типа Queue:
    Queue – коллекция, предназначенная для обработки элементов в определенном порядке (обычно FIFO).
    Основные реализации:
    LinkedList: Может использоваться как Queue.
    PriorityQueue: Элементы упорядочиваются в соответствии с их приоритетом (например, по числовому значению).
53. Коллекции типа Map и их принципиальное отличие:
    Map – коллекция, хранящая пары ключ-значение.
    Принципиальное отличие: Map хранит данные в виде пар “ключ-значение”. Ключи должны быть уникальными. По ключу можно получить связанное с ним значение. List, Set и Queue хранят только значения.
54. Основные реализации List, Set, Map:
    (Перечислены в пункте 48)
    List: ArrayList, LinkedList, Vector, Stack
    Set: HashSet, TreeSet, LinkedHashSet
    Map: HashMap, TreeMap, LinkedHashMap, Hashtable
55. Общее между ArrayList и LinkedList, когда какой лучше использовать:
    Общее: Оба являются реализациями интерфейса List. Оба хранят упорядоченные наборы элементов.
    Отличия и выбор:
    ArrayList: Реализован на основе массива. Быстрый доступ к элементам по индексу (O(1)), но медленная вставка/удаление в середине списка (O(n)). Лучше использовать, когда требуется частый доступ к элементам по индексу и не требуется часто вставлять/удалять элементы в середине списка.
    LinkedList: Реализован на основе связанного списка. Быстрая вставка/удаление в любом месте списка (O(1)), но медленный доступ к элементам по индексу (O(n)). Лучше использовать, когда требуется часто вставлять/удалять элементы в середине списка и не требуется часто обращаться к элементам по индексу.
56. HashSet:
    HashSet – реализация интерфейса Set, которая использует хеш-функцию для хранения элементов.
    Элементы хранятся в неупорядоченном порядке.
    Не допускает дубликаты (если добавить дубликат, он не будет добавлен).
    Обеспечивает быстрый поиск, добавление и удаление элементов (в среднем, O(1)).
    Не гарантирует порядок итерации по элементам.
57. TreeSet:
    TreeSet – реализация интерфейса Set, которая хранит элементы в отсортированном порядке. Использует дерево для хранения элементов (обычно, красно-черное дерево).
    Элементы сортируются по умолчанию в возрастающем порядке (если элементы реализуют Comparable) или с использованием переданного Comparator.
    Не допускает дубликаты.
    Обеспечивает гарантированный порядок итерации.
    Добавление, удаление и поиск немного медленнее, чем у HashSet (O(log n)).
58. Порядок следования объектов в коллекции, сортировка коллекции:
    List: Порядок следования элементов определяется порядком добавления. Для сортировки List можно использовать методы Collections.sort() (требует, чтобы элементы реализовывали Comparable или использовать Comparator).
    Set:  HashSet не гарантирует порядок.  TreeSet хранит элементы в отсортированном порядке. LinkedHashSet сохраняет порядок добавления.
    Map:  HashMap не гарантирует порядок. TreeMap хранит ключи в отсортированном порядке. LinkedHashMap сохраняет порядок добавления ключей.
    Сортировка коллекции:
    Для объектов, реализующих Comparable: Collections.sort(list)
    Для объектов, не реализующих Comparable: Collections.sort(list, comparator), где comparator – объект, реализующий интерфейс Comparator.
59. Iterator: как получить, методы:
    Iterator – это интерфейс, который позволяет перебирать элементы коллекции.
    Как получить Iterator:
    Вызывается метод iterator() у объекта коллекции (например, ArrayList, HashSet).
    Методы:
    hasNext(): Возвращает true, если в коллекции есть еще элементы.
    next(): Возвращает следующий элемент в итерации. Может выбросить NoSuchElementException, если больше нет элементов.
    remove(): Удаляет текущий элемент, возвращенный методом next(). Может быть вызвана только один раз после вызова next(). Может выбросить IllegalStateException, если next() не был вызван, или remove() был вызван уже после предыдущего вызова next().
60. Iterable:
    Iterable – это интерфейс, который определяет контракт для объектов, которые могут быть перебраны с помощью цикла for-each.
    Контракт:  Iterable должен предоставлять метод iterator(), который возвращает объект Iterator.
61. Коллекция из 10 элементов. Вызываем 9x Iterator.hasNext() а затем Iterator.next(). Что вернется?
    Iterator.hasNext() вернет true 9 раз.
    Iterator.next() вернет последовательно 9 элементов коллекции.
62. Как перебрать все ключи и значения Map (можно ли через Iterable):
    Перебор ключей:
    Получить Set ключей с помощью keySet(). Этот Set реализует Iterable, и можно перебрать ключи с помощью цикла for-each или Iterator.
    Перебор значений:
    Получить Collection значений с помощью values(). Эта Collection реализует Iterable, и можно перебрать значения с помощью цикла for-each или Iterator.
    Перебор пар ключ-значение:
    Получить Set записей (Entries) с помощью entrySet(). Каждая запись – это пара ключ-значение. entrySet() возвращает Set объектов типа Map.Entry<K, V>.
    Map.Entry реализует Iterable, и можно перебрать записи с помощью цикла for-each или Iterator.
    Да, через Iterable: Все методы keySet(), values() и entrySet() возвращают объекты, реализующие Iterable, поэтому можно использовать цикл for-each.
63. Разница Iterator, Enumerator, ListIterator:
    Iterator: Основной интерфейс для перебора элементов в коллекциях Java. Предоставляет методы hasNext(), next() и remove().
    Enumerator: Устаревший интерфейс, который был использован в старых коллекциях (до Java 2). Предоставляет методы hasMoreElements() и nextElement(). Менее функционален, чем Iterator. Не имеет метода remove().
    ListIterator: Интерфейс, который расширяет Iterator и предоставляет больше возможностей для работы с List. Предоставляет методы для двунаправленной итерации (перебор вперед и назад), добавления, замены и получения индекса текущего элемента.
64. ConcurrentModificationException:
    ConcurrentModificationException выбрасывается, когда коллекция изменяется во время итерации по ней (например, добавление или удаление элементов) одним потоком.
    Причины:
    Изменение коллекции напрямую (например, с помощью add(), remove()) во время итерации.
    Использование Iterator.remove() (это разрешено).
    Решение:
    Использовать Iterator.remove() для удаления элементов во время итерации.
    Использовать CopyOnWriteArrayList (или другие потокобезопасные коллекции) для работы в многопоточной среде.
    Создать новый список и добавить элементы, которые не нужно удалять, а затем заменить старый список новым.
65. Что такое Stream API?
        Stream API в Java - это как конвейер для обработки данных. Представьте, что у вас есть река (данные) и вы хотите ее очистить, отсортировать и использовать воду для разных целей. Stream API позволяет вам выполнять эти операции последовательно, как на конвейере, без изменения исходной реки. Он предоставляет набор операций для фильтрации, преобразования, сортировки и агрегации данных из различных источников (коллекций, массивов, файлов и т.д.).
66. Основные преимущества использования Stream API:
    Компактный и читаемый код: Выразительные операции позволяют писать код, который легко читается и понимается.
    Параллельная обработка: Легко распараллелить обработку данных, используя несколько ядер процессора, что может значительно ускорить выполнение операций.
    Ленивые вычисления: Операции выполняются только тогда, когда это необходимо, что позволяет оптимизировать производительность.
    Функциональный стиль программирования: Поощряет использование функций без побочных эффектов, что делает код более предсказуемым и тестируемым.
67. Основные операции в Stream API:
    Stream API состоит из двух видов операций:
    Промежуточные (intermediate):
    filter(): Фильтрует элементы, оставляя только те, которые удовлетворяют заданному условию.
    map(): Преобразует каждый элемент потока в другой элемент.
    flatMap(): Преобразует каждый элемент потока в поток, а затем объединяет все эти потоки в один.
    sorted(): Сортирует элементы потока.
    distinct(): Удаляет дубликаты из потока.
    peek(): Выполняет операцию с каждым элементом потока, не изменяя его. Полезно для отладки.
    Терминальные (terminal):
    forEach(): Выполняет операцию с каждым элементом потока.
    collect(): Собирает элементы потока в коллекцию (например, List, Set, Map).
    reduce(): Выполняет агрегацию элементов потока в одно значение (например, сумма, среднее).
    count(): Возвращает количество элементов в потоке.
    anyMatch(), allMatch(), noneMatch(): Проверяют, соответствует ли хотя бы один элемент, все элементы или ни один элемент потока заданному условию.
    findFirst(), findAny(): Возвращают первый или любой элемент потока (в виде Optional).
68. Объединение нескольких Stream:
    Можно объединить несколько Stream с помощью метода Stream.concat():
    Stream<Integer> stream1 = Stream.of(1, 2, 3);
    Stream<Integer> stream2 = Stream.of(4, 5, 6);
    Stream<Integer> combinedStream = Stream.concat(stream1, stream2);

combinedStream.forEach(System.out::println); // Вывод: 1 2 3 4 5 6

69. Обработка ошибок в Stream API:
    Stream API сам по себе не предоставляет встроенных механизмов обработки ошибок, но можно использовать try-catch блоки внутри операций map() или forEach():
    Stream<String> stringStream = Stream.of("1", "2", "a", "4");

stringStream.forEach(s -> {
try {
int number = Integer.parseInt(s);
System.out.println(number);
} catch (NumberFormatException e) {
System.err.println("Ошибка: Не удалось преобразовать строку '" + s + "' в число.");
}
});

70. Метод filter():
    Принимает: Predicate<T>, то есть функциональный интерфейс, принимающий элемент типа T и возвращающий boolean (условие фильтрации).
    Возвращает: Stream<T>, то есть новый поток, содержащий только те элементы, которые удовлетворяют условию фильтрации.
71. Метод Collectors.groupingBy():
    Принимает:
    Function<? super T, ? extends K> classifier: Функция, которая преобразует элемент типа T в ключ типа K.
    (Опционально) Collector<? super T, A, D> downstream: Дополнительный коллектор, который применяется к значениям, сгруппированным по ключу. Если не указан, используется toList().
    Возвращает: Collector<T, ?, Map<K, List<T>>>, то есть коллектор, который группирует элементы типа T в Map<K, List<T>>, где K - тип ключа, а List<T> - список элементов, сгруппированных по этому ключу.
    Пример:
    List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30),
    new Person("Charlie", 25)
    );

Map<Integer, List<Person>> peopleByAge = people.stream()
.collect(Collectors.groupingBy(Person::getAge));

System.out.println(peopleByAge); // Вывод: {25=[Person{name='Alice', age=25}, Person{name='Charlie', age=25}], 30=[Person{name='Bob', age=30}]}


72. Преобразование одного типа данных в другой:
    Можно использовать метод map() для преобразования каждого элемента потока в другой тип:
    int[] numbers = {1, 2, 3};
    Stream<Integer> integerStream = Arrays.stream(numbers).boxed(); // int -> Integer
    Stream<String> stringStream = integerStream.map(String::valueOf); // Integer -> String

stringStream.forEach(System.out::println); // Вывод: 1 2 3

Для преобразования int[] в IntStream можно использовать Arrays.stream(numbers). Для обратного преобразования (IntStream в int[]) можно использовать IntStream.toArray().
73. Отличия flatMap от map:
    map(): Преобразует каждый элемент потока в один новый элемент. Например, преобразует строку в ее длину.
    flatMap(): Преобразует каждый элемент потока в поток, а затем объединяет все эти потоки в один общий поток. Используется для “разворачивания” коллекций внутри коллекций. Например, у вас есть список списков чисел, и вы хотите получить один плоский список всех чисел.
74. Параллельные потоки:
    Чтобы создать параллельный поток, нужно вызвать метод parallelStream() вместо stream():
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

numbers.parallelStream()
.filter последовательная, и может потребовать дополнительных затрат на синхронизацию.

**75. Метод `forEach()`:**

*   **Принимает:** `Consumer<T>`, то есть функциональный интерфейс, принимающий элемент типа `T` и выполняющий над ним какое-либо действие.
*   **Возвращает:** `void`. Метод `forEach()` является терминальной операцией и не возвращает никакого значения.  Он просто выполняет действие для каждого элемента потока.

**76. Метод `peek()`:**

*   **Принимает:** `Consumer<T>`, то есть функциональный интерфейс, принимающий элемент типа `T` и выполняющий над ним какое-либо действие.
*   **Возвращает:** `Stream<T>`, то есть тот же самый поток, с которым он был вызван. Метод `peek()` является промежуточной операцией и не изменяет элементы потока. Он полезен для отладки и просмотра элементов потока на промежуточных этапах обработки.

**77. Метод `reduce()`:**

*   **Принимает:**
    *   **Вариант 1:** `T identity, BinaryOperator<T> accumulator`
        *   `identity`: Начальное значение (например, 0 для суммы).
        *   `accumulator`: Функция, которая принимает два значения типа `T` и возвращает новое значение типа `T` (например, `(a, b) -> a + b`).
    *   **Вариант 2:** `BinaryOperator<T> accumulator`
        *   `accumulator`: Функция, которая принимает два значения типа `T` и возвращает новое значение типа `T`.  Возвращает `Optional<T>`, так как начального значения нет и может оказаться, что поток пустой.
    *   **Вариант 3:** `U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner` (для параллельных потоков)
        *   `identity`: Начальное значение.
        *   `accumulator`: Функция, которая принимает промежуточный результат типа `U` и элемент потока типа `T` и возвращает новый промежуточный результат типа `U`.
        *   `combiner`: Функция, которая объединяет два промежуточных результата типа `U` в один результат типа `U`.
*   **Возвращает:**
    *   Вариант 1: `T` (результат агрегации).
    *   Вариант 2: `Optional<T>` (результат агрегации, если поток не пустой).

**78. Бесконечный поток:**

Можно создать бесконечный поток с помощью методов `Stream.iterate()` или `Stream.generate()`:

// Stream.iterate()
Stream<Integer> infiniteStream1 = Stream.iterate(0, n -> n + 1); // Начинаем с 0 и увеличиваем на 1
infiniteStream1.limit(10).forEach(System.out::println); // Вывод: 0 1 2 3 4 5 6 7 8 9

// Stream.generate()
Stream<Double> infiniteStream2 = Stream.generate(Math::random); // Генерируем случайные числа
infiniteStream2.limit(5).forEach(System.out::println); // Вывод: 5 случайных чисел

79. Ограничения Stream API:
Однократное использование: Поток можно использовать только один раз. После выполнения терминальной операции поток становится “закрытым”, и его нельзя использовать повторно.
Не изменяет исходные данные: Stream API не изменяет исходные данные. Он создает новый поток, содержащий результаты операций.
Отсутствие прямого доступа к элементам: В Stream API нельзя получить доступ к элементам по индексу.
80. Передача переменной в стрим и что с ней можно сделать:
Переменную можно передать в стрим через лямбда-выражение:
String prefix = "Element: ";
List<String> data = Arrays.asList("A", "B", "C");

data.stream().forEach(s -> System.out.println(prefix + s));

Внутри лямбда-выражения можно:
Читать значение переменной: (как в примере выше)
Нельзя изменять значение переменной, если она не является final или effectively final (то есть, фактически не изменяется после инициализации). Это связано с тем, что лямбда-выражения захватывают переменные из внешнего контекста, и изменение этих переменных может привести к проблемам с потоками.
81. Создание Optional:
Optional.of(value): Создает Optional, содержащий указанное значение. Если value равно null, выбрасывается NullPointerException.
Optional.ofNullable(value): Создает Optional, который может содержать значение или быть пустым (если value равно null).
Optional.empty(): Создает пустой Optional.
82. Отличие Optional.of() и Optional.ofNullable():
Optional.of(value): Подходит, если вы уверены, что value не будет null. Если value окажется null, будет выброшено исключение.
Optional.ofNullable(value): Подходит, если value может быть null. Создаст пустой Optional, если value равен null.
83. Отличие методов ifPresent и orElse в контексте Optional:
ifPresent(Consumer<T> consumer): Выполняет указанное действие (Consumer) только в том случае, если Optional содержит значение. Ничего не возвращает.
orElse(T other): Возвращает значение, содержащееся в Optional, если оно присутствует. В противном случае (если Optional пустой) возвращает указанное значение по умолчанию other.
84. Объединение двух Optional в один (метод join):
Метод join не существует в стандартном API Optional. Но можно написать свой метод для объединения двух Optional.
Вот один из возможных вариантов реализации (не самый элегантный, но показывает суть):
public static <T> Optional<T> join(Optional<T> optional1, Optional<T> optional2) {
    if (optional1.isPresent()) {
        return optional1;
    } else {
        return optional2;
    }
}


В этом примере, если optional1 содержит значение, то возвращается optional1, иначе возвращается optional2. Другие стратегии объединения (например, выбрать большее или меньшее значение, объединить строки) могут быть реализованы аналогично.
В более сложных случаях, когда нужно объединить значения из двух Optional с помощью какой-либо функции, можно использовать комбинацию flatMap и map.
85. Что проверяет ifPresent Optional?
Метод ifPresent(Consumer<T> consumer) проверяет, содержит ли Optional значение. Если Optional не пустой (то есть содержит значение), то выполняется переданный Consumer. Если Optional пустой, то ничего не происходит.
86. Преобразование Stream в массив или коллекцию:
В массив:
toArray(): Возвращает массив типа Object[].
toArray(T[]::new): Возвращает массив указанного типа T[].
String[] array = stream.toArray(String[]::new);


В коллекцию:
collect(Collectors.toList()): Собирает элементы в List.
collect(Collectors.toSet()): Собирает элементы в Set.
collect(Collectors.toCollection(LinkedList::new)): Собирает элементы в указанную реализацию Collection (в данном случае, LinkedList).
collect(Collectors.toMap(keyMapper, valueMapper)): Собирает элементы в Map.
List<String> list = stream.collect(Collectors.toList());


87. Отличие методов orElseGet и orElse:
orElse(T other): Возвращает значение, содержащееся в Optional, если оно присутствует. В противном случае возвращает указанное значение по умолчанию other. Значение other вычисляется всегда, независимо от того, содержит ли Optional значение или нет.
orElseGet(Supplier<T> supplier): Возвращает значение, содержащееся в Optional, если оно присутствует. В противном случае возвращает результат вызова Supplier (функции, которая предоставляет значение по умолчанию).  Supplier вызывается только в том случае, если Optional пустой.
Разница важна, когда вычисление значения по умолчанию ресурсоемкое:
Если вычисление значения other занимает много времени или требует ресурсов, то лучше использовать orElseGet.
88. Обработка ошибок с Optional и orElseThrow:
orElseThrow() позволяет выбросить исключение, если Optional не содержит значение:
String value = Optional.ofNullable(null)
        .orElseThrow(() -> new IllegalArgumentException("Value cannot be null"));

В этом примере, если Optional пустой, будет выброшено IllegalArgumentException с указанным сообщением.  orElseThrow() принимает Supplier<X extends Throwable>, то есть функцию, которая создает исключение. Это позволяет создавать исключения динамически, например, передавая в него какие-то параметры.
89. Иерархия исключений:
    В Java все исключения являются классами, которые наследуются от класса Throwable. Иерархия выглядит так:
    Throwable (базовый класс для всех исключений)
    Error (ошибки, которые обычно не нужно и нельзя обрабатывать в программе. Связаны с проблемами в JVM)
    Exception (исключения, которые можно и нужно обрабатывать в программе)
    RuntimeException (исключения времени выполнения, unchecked)
    (Другие классы исключений, наследующиеся от Exception, например IOException, SQLException, checked)
90. Определение понятия “исключение”:
    Исключение (Exception) - это событие, которое прерывает нормальный поток выполнения программы. Оно возникает, когда происходит какая-то ошибка или непредвиденная ситуация (например, деление на ноль, отсутствие файла, некорректный ввод данных). Исключения позволяют перехватывать и обрабатывать эти ошибки, чтобы программа не завершалась аварийно.
91. Конструкция для обработки исключений:
    Для обработки исключений в Java используется конструкция try-catch-finally:
    try {
    // Код, в котором может возникнуть исключение
    // ...
    } catch (ИсключениеТипа1 e1) {
    // Обработка исключения ИсключениеТипа1
    // ...
    } catch (ИсключениеТипа2 e2) {
    // Обработка исключения ИсключениеТипа2
    // ...
    } finally {
    // Код, который выполняется всегда, независимо от того,
    // возникло исключение или нет
    // ...
    }

92. Обработка ошибок JVM:
    Ошибки JVM (Error, например, OutOfMemoryError) обычно обрабатывать не нужно и нельзя. Они указывают на критические проблемы, которые могут быть вызваны нехваткой памяти, ошибками в работе JVM и т.д.. Попытки их обработки, как правило, не приведут к успеху. Лучше понимать природу ошибки, и не допускать ее (например, настройка JVM, оптимизация кода)
93. Способы обработки исключений:
    Перехват и обработка (try-catch): Перехватываем исключение в блоке catch и выполняем код для обработки ошибки (например, логирование, отображение сообщения об ошибке пользователю, восстановление состояния программы).
    Проброс исключения (throws): Если метод не может обработать исключение, он может “пробросить” его дальше, указав в заголовке метода ключевое слово throws. Исключение будет обработано в вызывающем методе.
    Не обрабатывать: Если исключение unchecked (например, RuntimeException и его подклассы), его можно не обрабатывать. В этом случае исключение будет “всплывать” по стеку вызовов, пока не будет перехвачено или не приведет к завершению программы.
94. Ключевое слово throws:
    Ключевое слово throws используется в заголовке метода для указания типов исключений, которые этот метод может выбросить (но не обрабатывает сам). Оно сообщает вызывающему методу о том, что ему нужно будет позаботиться об обработке этих исключений.
95. Блок finally:
    Особенность: Блок finally выполняется всегда, независимо от того, возникло исключение в блоке try или нет, и было ли оно перехвачено блоком catch или нет.
    Всегда ли исполняется? Почти всегда.
    Назначение: Используется для освобождения ресурсов (например, закрытие файлов, соединений с базой данных), которые были выделены в блоке try, чтобы избежать утечек ресурсов.
96. Когда блок finally не будет выполнен:
    Если в блоке try или catch вызывается System.exit(0) (завершение работы JVM).
    Если поток, в котором выполняется блок try-catch-finally, прерывается.
97. Отсутствие блока catch:
    Да, блок catch может отсутствовать. В этом случае исключение будет “проброшено” вызывающему методу (если метод объявлен с throws) или приведет к завершению программы. Блок finally (если он есть) будет выполнен.
98. (Checked/Unchecked) исключения:
    Checked исключения: Наследуются от класса Exception, но не от RuntimeException. Компилятор требует, чтобы checked исключения были либо обработаны в блоке try-catch, либо указаны в заголовке метода с помощью throws. Это помогает избежать ошибок, связанных с необработанными исключениями. Пример: IOException.
    Unchecked исключения: Наследуются от класса RuntimeException (и его подклассов) или от Error. Компилятор не требует, чтобы unchecked исключения были обработаны или проброшены. Эти исключения обычно указывают на проблемы с логикой программы (например, NullPointerException, ArrayIndexOutOfBoundsException). Поэтому, их обработка не обязательна.
99. Несколько блоков catch:
    Да, один блок try может иметь несколько блоков catch. Блоки catch перехватывают исключения определенного типа. Порядок блоков catch важен:
    Блоки catch должны быть расположены от более специфичных типов исключений к более общим (например, от IOException к Exception). Если блок catch для более общего типа исключения стоит раньше, чем блок для более специфичного, то компилятор выдаст ошибку, так как более специфичный блок никогда не будет выполнен.
    Один блок catch не может отлавливать несколько исключений (в классическом варианте). Для этого необходимо создавать отдельные блоки catch для каждого типа исключения (или использовать | начиная с Java 7).
100. Особенность RuntimeException:
     RuntimeException и его подклассы - это unchecked исключения.
     Компилятор не требует явной обработки или проброса этих исключений.
     Они обычно указывают на ошибки в логике программы, которые можно исправить, изменив код. Например, NullPointerException возникает при попытке доступа к методу или полю null объекта.
101. Выбор: checked/unchecked:
     Checked исключения: Используются для ошибок, которые могут возникнуть из-за внешних факторов (например, ошибка ввода/вывода, проблемы с сетью). Компилятор требует, чтобы эти исключения были обработаны, что повышает надежность кода.
     Unchecked исключения: Используются для ошибок, которые обычно указывают на проблемы с кодом (например, ошибки программирования). Не требуют обязательной обработки.
     Выбор зависит от природы ошибки. Если ошибка, скорее всего, может быть исправлена в процессе выполнения программы, то лучше использовать RuntimeException и его подклассы (unchecked). Если ошибка связана с внешними факторами, от которых программа не зависит и обязательна обработка, то стоит использовать Exception (checked).
102. Принудительный выброс исключения:
     Для принудительного выброса исключения используется оператор throw:
     throw new ИсключениеТипа("Сообщение об ошибке");

103. Дополнительные условия к методу, который может выбросить исключение:
     Если метод может выбросить checked исключение, он должен быть объявлен с помощью throws:
     public void readFile(String filename) throws IOException {
     // ... код, который может выбросить IOException
     }
      Это сообщает вызывающему коду о том, что ему нужно будет обработать это исключение.
104. main метод и исключения:
     Да, метод main может выбросить исключение. Если исключение не перехвачено внутри main, оно будет “проброшено” дальше и приведет к завершению работы программы с выводом информации об исключении в консоль. Обработка исключения в main не отличается от обработки в любом другом методе: можно использовать try-catch или throws.
105. return в catch и finally:
     Если оператор return содержится и в блоке catch и в finally, то всегда будет выполнен оператор return из блока finally. Это связано с тем, что блок finally выполняется в любом случае, даже если в блоке try или catch уже есть оператор return.
106. OutOfMemoryError, SQLException:
     OutOfMemoryError:
     Тип: Error (unchecked).
     Почему: Указывает на критическую проблему (нехватку памяти), которую, как правило, нельзя обработать в программе.
     SQLException:
     Тип: Exception (checked).
     Почему: Указывает на проблемы при работе с базой данных (например, ошибка SQL, проблемы с соединением). Эти ошибки требуют обработки.
107. Error:
     Error - это класс, представляющий ошибки, которые обычно не нужно и нельзя обрабатывать в программе. Они указывают на критические проблемы, которые не позволяют программе продолжать работу.
     Примеры:
     OutOfMemoryError: Нехватка памяти.
     StackOverflowError: Переполнение стека вызовов.
     LinkageError: Ошибки, связанные с загрузкой и связыванием классов.
     AssertionError: Ошибка, возникшая в результате неудавшейся проверки утверждения.
108. SHA-1 в Git:
     SHA-1 (Secure Hash Algorithm 1) – это криптографическая хеш-функция. В Git она используется для:
     Идентификации объектов: Каждый объект Git (файл, коммит, дерево каталогов, тэг) идентифицируется уникальным SHA-1 хешем. Это гарантирует целостность данных. Если содержимое объекта изменится, хеш тоже изменится.
     Обнаружения изменений: Git использует SHA-1 для определения, какие файлы изменились между коммитами.
     Оптимизации хранения: Git хранит только изменения (diff) между версиями файлов, используя SHA-1 для идентификации этих версий.
109. Основные состояния файла в Git:
     Файл в Git может находиться в одном из трех основных состояний:
     Untracked (Неотслеживаемый): Файл находится в вашем рабочем каталоге, но Git еще не знает о нем.
     Tracked (Отслеживаемый): Git знает об этом файле. Он может находиться в одном из двух подсостояний:
     Unmodified (Неизмененный): Файл не изменялся с момента последнего коммита.
     Modified (Измененный): Файл был изменен, но еще не был добавлен в индекс (staging area).
     Staged (В индексе/staging area): Файл был добавлен в индекс и будет включен в следующий коммит.
110. Команды git init, копирование удаленной репы:
     git init: Инициализирует новый Git-репозиторий в текущем каталоге. Создает скрытую папку .git, в которой хранится вся информация о репозитории (история коммитов, ветки, конфигурация).
     Копирование удаленной репы: Используется команда git clone <URL репозитория>. Эта команда:
     Клонирует (копирует) весь репозиторий (включая историю коммитов) из удаленного репозитория (например, с GitHub, GitLab или Bitbucket) в вашу локальную систему.
     Создает папку с именем репозитория (по умолчанию).
     Создает локальную ветку main (или master в старых версиях Git), которая отслеживает удаленную ветку main.
     Настраивает связь с удаленным репозиторием (обычно с именем origin).
111. После создания коммита:
     После создания коммита:
     Создается новый объект коммита (с SHA-1 хешем) в репозитории.
     Этот объект содержит:
     Снимок (snapshot) текущего состояния файлов в индексе.
     Информацию о коммиттере (авторе коммита).
     Сообщение коммита (описание изменений).
     Ссылки на родительские коммиты (чтобы отслеживать историю).
     Указатель HEAD перемещается на новый коммит.
     Ветка, на которой был создан коммит, перемещается на новый коммит.
     Рабочий каталог и индекс остаются неизменными (если вы не создали новые файлы или не изменили существующие).
112. Добавление и фиксация коммита:
     Добавление изменений в индекс (staging area): Используется команда git add <файл или паттерн файлов>. Эта команда добавляет изменения в файлы (или новые файлы) в индекс.
     Фиксация (создание коммита): Используется команда git commit -m "<сообщение коммита>" или git commit. Эта команда создает новый коммит на основе текущего состояния индекса. Сообщение коммита должно описывать внесенные изменения. Если использовать git commit без -m, откроется текстовый редактор, где можно будет написать более подробное сообщение.
113. Отправка коммитов на сервер:
     Да, обычно отправка коммитов на сервер (удаленный репозиторий) является важной частью рабочего процесса Git. Это позволяет:
     Сохранить изменения: Обеспечивает резервное копирование вашего кода.
     Сотрудничать: Делиться изменениями с другими разработчиками.
     Развертывать код: Использовать изменения для развертывания приложения.
     Команда для отправки (push) коммитов на сервер: git push <имя_удаленного_репозитория> <имя_ветки>. Например, git push origin main.
114. git fetch:
     git fetch загружает изменения (коммиты, ветки, теги) из удаленного репозитория в ваш локальный репозиторий, но не объединяет их с вашими локальными ветками. Это безопасно: ваш рабочий каталог не изменится. Она позволяет вам:
     Увидеть, какие изменения были внесены в удаленном репозитории.
     Обновить информацию о удаленных ветках.
     Подготовить к слиянию (merge) или перебазированию (rebase).
115. git merge:
     git merge объединяет изменения из одной ветки в другую. Она создает новый коммит с двумя родительскими коммитами (один из текущей ветки, другой - из сливаемой ветки), объединяя историю этих веток.
116. Автоматическое разрешение конфликтов:
     Git не разрешает конфликты автоматически. Если Git обнаруживает конфликты (различные изменения в одних и тех же строках файла), он отмечает эти конфликты в файле и вам нужно будет вручную их разрешить, отредактировав файл и указав, какие изменения следует сохранить.
117. git pull с незафиксированными изменениями:
     Нет, git pull (которая выполняет git fetch и git merge) не может быть выполнена, если в рабочем каталоге есть незафиксированные изменения (изменения, которые не были добавлены в индекс с помощью git add и зафиксированы с помощью git commit). Git выдаст ошибку. Нужно либо зафиксировать изменения, либо сохранить их (например, с помощью git stash).
118. git cherry-pick:
     git cherry-pick позволяет применить отдельный коммит (или несколько коммитов) из одной ветки в другую. Команда берет коммит по его SHA-1 хешу и создает новый коммит в текущей ветке, содержащий те же изменения, что и исходный коммит.
     Можно указать несколько коммитов, перечислив их SHA-1 хеши через пробел. В этом случае Git применит эти коммиты последовательно.
119. Цель указателя HEAD:
     HEAD – это указатель на текущий коммит (или ветку) в вашем локальном репозитории. Он показывает, какой коммит является “текущим” и на основе которого будут создаваться новые коммиты.
120. Конфликты:
     Конфликты возникают, когда:
     В одной и той же строке файла были внесены изменения в разных ветках.
     Один и тот же файл был удален в одной ветке и изменен в другой.
     Git не может автоматически разрешить такие конфликты, поэтому требует ручного вмешательства.
121. Изменение истории коммитов (rebase, amend):
     git rebase: Переносит (перебазирует) ветку на другой коммит (или ветку). Создает новые коммиты для каждой изменения, примененного на вершине другой ветки. Изменяет историю коммитов.
     git commit --amend: Позволяет изменить последнее сообщение коммита или добавить в него изменения из индекса. Изменяет последний коммит.
122. git merge vs. git rebase:
     git merge: Создает коммит слияния, объединяя две ветки. Сохраняет историю (видно, когда ветки разошлись и были объединены). Не изменяет историю коммитов, добавляя новый коммит.
     git rebase: Переносит (перебазирует) ветку на другой коммит (или ветку). Изменяет историю коммитов, перезаписывая коммиты, которые были применены на вершине другой ветки. Делает историю более линейной, но может привести к проблемам при работе с общими ветками (т.к. изменяет SHA-1 хеши коммитов).
     О чем следует помнить при изменении истории веток:
     Не изменяйте общую историю: Не используйте rebase на ветках, которые уже были отправлены в удаленный репозиторий и с которыми работают другие разработчики. Это может привести к путанице и конфликтам.
     Осторожность: Всегда делайте резервную копию репозитория или создавайте ветку для экспериментов перед тем, как изменять историю.
     Коммуникация: Если вы изменяете историю ветки, с которой работают другие разработчики, обязательно сообщите им об этом.
123. Разрешение конфликтов:
     Откройте файл, в котором возник конфликт: Git отметит конфликтующие участки в файле: <<<<<<< HEAD, =======, >>>>>>> <имя_ветки>.
     Отредактируйте файл: Удалите маркеры конфликта (<<<<<<<, =======, >>>>>>>). Оставьте только нужные вам изменения.
     Добавьте файл в индекс: git add <файл>
     Зафиксируйте (если необходимо): Если вы выполняли git merge или git rebase, то после разрешения конфликтов выполните git commit.
124. git remote и git clone:
     git remote: Команда для управления удаленными репозиториями. Позволяет добавить, удалить, просмотреть удаленные репозитории, с которыми связан ваш локальный репозиторий. Например, git remote add origin <URL репозитория> добавляет удаленный репозиторий с именем origin.
     git clone: Команда для клонирования (копирования) удаленного репозитория в вашу локальную систему.
125. Detached HEAD:
     Detached HEAD (отсоединенный HEAD) - это состояние, когда HEAD указывает непосредственно на коммит (а не на ветку). Это означает, что вы находитесь вне какой-либо ветки. Это может произойти, например, при переключении на определенный коммит (с помощью git checkout <SHA-1 хеш коммита>) или при git cherry-pick. Обычно не рекомендуется делать коммиты в состоянии detached HEAD, так как вы можете потерять эти коммиты, если не создадите ветку на основе этого коммита.
126. Варианты reset:
     git reset используется для отмены изменений. Она перемещает указатель HEAD и, при необходимости, индекс и рабочий каталог:
     git reset --soft <commit>: Перемещает HEAD на указанный коммит, но не изменяет индекс и рабочий каталог. Изменения остаются в индексе (staged), готовые к коммиту.
     git reset --mixed <commit> (по умолчанию): Перемещает HEAD на указанный коммит и сбрасывает индекс. Изменения в рабочем каталоге остаются, но не добавлены в индекс.
     git reset --hard <commit>: Перемещает HEAD на указанный коммит, сбрасывает индекс и изменяет рабочий каталог, отменяя все изменения, сделанные после указанного коммита. Осторожно: необратимая операция!
127. git revert:
     git revert создает новый коммит, который отменяет изменения, внесенные в указанный коммит. Не изменяет историю коммитов. Это безопасная операция, которую можно использовать для отмены изменений в общей ветке, так как она не перезаписывает историю.
128. Снос удаленной ветки:
     Для сноса (удаления) удаленной ветки используется команда: git push origin --delete <имя_ветки>. Или, начиная с Git 2.8: git push origin :<имя_ветки>. Эта команда удаляет ветку на удаленном репозитории.
